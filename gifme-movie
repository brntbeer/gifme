#!/bin/sh
#
# Handles movie deconstruction to hand off to `gifme`. You probably want to
# use `gifme` instead of running this script directly, since this doesn't
# handle animations.
#
#
#/ USAGE: gifme-movie <file> <time> <duration>
#/
#/   file -     The path to the movie we're converting.
#/   time -     The start time of the finished product.
#/              This can be in seconds, or it also accepts the
#/              "hh:mm:ss[.xxx]" format.
#/   duration - The duration of the video sequence.
#/              This can be in seconds, or it also accepts the
#/              "hh:mm:ss[.xxx]" format.
#/
#/ Examples:
#/
#/   gifme-movie <path> <start-time> <duration>
#/   ~/Desktop/dr-strangelove.mp4 23:12 3
#/   ~/Desktop/holman-backflip-on-fire.mov 3.9 1.75
#/

set -e
set -o posix

# Print help/usage with no pattern/args
test $# -eq 0 -o "$1" = "--help" && {
    cat $0 | grep '^#/' | cut -c4-
    exit 0
}

# Should we actually run ffmpeg?
noop=false

# Get and set options
while getopts n opt; do
  case "$opt" in
    n)  noop=true;;
  esac
done

# Cleanup
rm -rf /tmp/gifme-movie

# Create tmp dir
mkdir -p /tmp/gifme-movie

# Split the movie into constituent frames
cmd='ffmpeg -i $1 -f image2 -ss $2 -t $3 -r 7 /tmp/gifme-movie/d-%05d.png > /tmp/gifme-movie.log 2>&1 /dev/null'

# If we're in test, don't actually run the command
if $noop
then
  echo $cmd
  exit 0
fi

$($cmd)